diff --git a/README.md b/README.md
index 9726594..61610c9 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 tamejs
 ======
 This package is a source-to-source translator that outputs JavaScript. The
-input dialect looks a lot like JavaScript, but introduces the `twait` 
+input dialect looks a lot like JavaScript, but introduces the `await` 
 primitive, which allows asynchronous callback style code to work more
 like straight-line threaded code.  *tamejs* is written in JavaScript.
 
@@ -21,34 +21,34 @@ slots in between:
 
 ```javascript  
 for (var i = 0; i < 10; i++) {
-    twait { setTimeout (mkevent (), 100); }
+    await { setTimeout (defer (), 100); }
     console.log ("hello");
 }
 ```
 
-There is one new language addition here, the `twait { ... }` block,
-and also one new primitive function, `mkevent`.  The two of them work
-in concert.  Within the context of a `twait` block, `mkevent` returns
+There is one new language addition here, the `await { ... }` block,
+and also one new primitive function, `defer`.  The two of them work
+in concert.  Within the context of a `await` block, `defer` returns
 anonymous callback functions associated with that block.  A function
-must "wait" at the close of a `twait` block until all callbacks made
-by `mkevent` in that `twait` block are called.  In the code above,
+must "wait" at the close of a `await` block until all callbacks made
+by `defer` in that `await` block are called.  In the code above,
 there is only one callback produced in each iteration of the loop, so
 after it's called by `setTimer` in 100ms, control continues past the
-`twait` block, onto the log line, and back to the next iteration of
+`await` block, onto the log line, and back to the next iteration of
 the loop.  The code looks and feels like threaded code, but is still
 in the asynchronous idiom (if you look at the rewritten code output by
 the *tamejs* compiler).
 
 This next example does the same, while showcasing power of the
-`twait{..}` language addition.  In the example below, the two timers
+`await{..}` language addition.  In the example below, the two timers
 are fired in parallel, and only when both have returned (after 100ms),
 does progress continue...
 
 ```javascript
 for (var i = 0; i < 10; i++) {
-    twait { 
-        setTimeout (mkevent (), 100); 
-        setTimeout (mkevent (), 10); 
+    await { 
+        setTimeout (defer (), 100); 
+        setTimeout (defer (), 10); 
     }
     console.log ("hello");
 }
@@ -62,16 +62,16 @@ var dns = require("dns");
 
 function do_one (ev, host) {
     var err, ip;
-    twait { dns.resolve (host, "A", mkevent (err, ip));}
+    await { dns.resolve (host, "A", defer (err, ip));}
     if (err) { console.log ("ERROR! " + err); } 
     else { console.log (host + " -> " + ip); }
     ev();
 }
 
 function do_all (lst) {
-    twait {
+    await {
         for (var i = 0; i < lst.length; i++) {
-            do_one (mkevent (), lst[i]);
+            do_one (defer (), lst[i]);
         }
     }
 }
@@ -93,13 +93,13 @@ And you will get a response:
 
 If you want to run these DNS resolutions in serial (rather than
 parallel), then the change from above is trivial: just switch the
-order of the `twait` and `for` statements above:
+order of the `await` and `for` statements above:
 
 ```javascript  
 function do_all (lst) {
     for (var i = 0; i < lst.length; i++) {
-        twait {
-            do_one (mkevent (), lst[i]);
+        await {
+            do_one (defer (), lst[i]);
         }
     }
 }
@@ -131,7 +131,7 @@ function do_all (lst, windowsz) {
             nsent++;
         } else {
             var evid;
-            twait { rv.wait (mkevent (evid)); }
+            await { rv.wait (defer (evid)); }
             console.log ("got back lookup nsent=" + evid);
             nrecv++;
         }
@@ -143,7 +143,7 @@ This code maintains two counters: the number of requests sent, and the
 number received.  It keeps looping until the last lookup is received.
 Inside the loop, if there is room in the window and there are more to
 send, then send; otherwise, wait and harvest.  `Rendezvous.mkev` makes
-an event much like the `mkevent` primitive, but it also takes a first
+an event much like the `defer` primitive, but it also takes a first
 argument that associates an idenitifer with the event fired.  This
 way, the waiter can know which event he's getting back.  In this case
 we use the variable `nsent` as the event ID --- it's the ID of this
@@ -160,20 +160,20 @@ Composing Serial And Parallel Patterns
 
 In Tame, arbitrary composition of serial and parallel control flows is
 possible with just normal functional decomposition.  Therefore, we
-don't allow direct `twait` nesting.  With inline anonymous JavaScript
+don't allow direct `await` nesting.  With inline anonymous JavaScript
 functions, you can consicely achieve interesting patterns.  The code
 below launches 10 parallel computations, each of which must complete
 two serial actions before finishing:
 
 ```javascript
 function f(cb) {
-    twait {
+    await {
         for (var i = 0; i < n; i++) {
             (function (cb) {
-                twait { setTimeout (mkevent (), 5*Math.random ()); }
-                twait { setTimeout (mkevent (), 4*Math.random ()); }
+                await { setTimeout (defer (), 5*Math.random ()); }
+                await { setTimeout (defer (), 4*Math.random ()); }
                 cb();
-             })(mkevent ());
+             })(defer ());
         }
     }
     cb();
@@ -202,9 +202,9 @@ require ("mylib.tjs");          // then use node.js's import as normal
 API and Documentation
 ---------------------
 
-### mkevent
+### defer
 
-`mkevent` can be called in one of three ways.  
+`defer` can be called in one of three ways.  
 
 
 #### Inline Variable Declaration
@@ -214,12 +214,12 @@ variables:
 
 ```javascript
 
-twait { dns.resolve ("okcupid.com", mkevent (var err, ip)); }
+await { dns.resolve ("okcupid.com", defer (var err, ip)); }
 
 ```
 
 In the tamed output code, the variables `err` and `ip` will be
-declared right before the start of the `twait` block that contains them.
+declared right before the start of the `await` block that contains them.
 
 
 #### Generic LHS Assignment
@@ -230,7 +230,7 @@ allows more flexibility:
 ```javascript
 var d = {};
 var err = [];
-twait { dns.resolve ("okcupid.com", mkevent (err[0], d.ip)); }
+await { dns.resolve ("okcupid.com", defer (err[0], d.ip)); }
 ```
 This second version allows anything you'd normally put on the
 left-hand side of an assignment.
@@ -238,16 +238,16 @@ left-hand side of an assignment.
 #### Variadic Return
 
 If you callback function might return an arbitrary number of elements,
-`mkevent` has a third mode that allows for variadic return:
+`defer` has a third mode that allows for variadic return:
 
 ```javascript
 var arr = []
-twait { dns.resolve ("okcupid.com", mkevent (arr)); }
+await { dns.resolve ("okcupid.com", defer (arr)); }
 var err = arr[0];
 var ip = arr[1];
 ```
 
-If `mkevent` sees that it's passed on parameter, and that parameter
+If `defer` sees that it's passed on parameter, and that parameter
 happens to be an empty array, it will choose this mode of operation.
 
 
@@ -262,14 +262,14 @@ The `Rendezvous` is similar to a blocking condition variable (or a
 
 #### tame.Rendezvous.mkev(id,arr)
 
-This is the `Rendezvous` equivalent of the `mkevent` built-in, but
+This is the `Rendezvous` equivalent of the `defer` built-in, but
 shortened so it doesn't confuse the *tamejs* compiler.  It takes two
 arguments, the event "ID" that the programmer is going to use to
 idenitify this event later on, and also a empty array to return values
 from the callback.  Thus, the `Rendezvous` only works in the third
-style of built-in `mkevent` call above, with variadic return.
+style of built-in `defer` call above, with variadic return.
 
-As with `mkevent`, the return value of `Rendezvous.mkev` is fed
+As with `defer`, the return value of `Rendezvous.mkev` is fed
 to function expecting a callback.  As soon as that callback fires,
 the slots of `arr` will be filled with the arguments to that callback.
 
@@ -281,7 +281,7 @@ before `wait` was called, then `cb` is fired immediately.
 
 Though `wait` would work with any hand-rolled JS function expecting
 a callback, it's meant to work particularly well with *tamejs*'s
-`twait` function.
+`await` function.
 
 #### Example
 
@@ -297,7 +297,7 @@ var rv = new tame.Rendezvous ();
 for (var i in hosts) {
     dns.resolve (hosts[i], rv.mkev (i, arr[i]));
 }
-twait { rv.wait (which); }
+await { rv.wait (which); }
 console.log (hosts[which] + " -> " + arr[which][1]);
 ```
 
@@ -325,7 +325,7 @@ require ('tamejs').register (); // since connectors is a tamed library...
 var timeout = require ('tamejs/lib/connectors').timeout;
 var info = [];
 var host = "pirateWarezSite.ru";
-twait { dns.lookup (host, timeout (mkevent (var err, ip), 100, info)); }
+await { dns.lookup (host, timeout (defer (var err, ip), 100, info)); }
 if (!info[0]) {
     console.log (host + ": timed out!");
 } else if (err) {
@@ -345,14 +345,14 @@ The key idea behind the *tamejs* implementation is
 (CPS)](http://en.wikipedia.org/wiki/Continuation-passing_style)
 compilation.  That is, elements of code like `for`, `while` and `if`
 statements are converted to anonymous JavaScript functions written
-in continuation-passing style.  Then, `twait` blocks just grab
+in continuation-passing style.  Then, `await` blocks just grab
 those continuations, store them away, and call them when the
 time is right (i.e., when all relevant events have completed).
 
 For example, the simple program:
 
 ```javascript
-if (true) { twait { setTimeout (mkevent (), 100); } }
+if (true) { await { setTimeout (defer (), 100); } }
 ```
 
 Is rewritten to something like the following (which has been hand-simplified
@@ -363,7 +363,7 @@ var tame = require('tamejs').runtime;
 var f0 = function (k) {
     var f1 = function (k) {
         var __ev = new tame.Event (k);
-        setTimeout ( __ev.mkevent(), 100 ) ;
+        setTimeout ( __ev.defer(), 100 ) ;
     };
     if (true) {
         f1 (k);
@@ -380,7 +380,7 @@ Function `f0` takes as a parameter the continuation `k`, which
 signifies "the rest of the program".  In the case of this trivial
 program, the rest of the program is just a call to the exit function
 `tame.end`.  Inside the `if` statement, there are two branches.  In
-the `true` branch, we call into `f1`, the rewrite of the `twait`
+the `true` branch, we call into `f1`, the rewrite of the `await`
 block, and in the `false` branch, it's just go on with the rest of the
 program by calling the continuation `k`.  Function `f1` is doing
 something a little bit different --- it's passing its continuation
@@ -399,39 +399,39 @@ The translation of `switch` is probably the trickiest.
 As you might guess, the output code is less efficient than the input
 code.  All of the anonymous functions add bloat.  This unfortunate
 side-effect of our approach is mitigated by skipping CPS compilation
-when possible.  Functions with no `twait` blocks are passed through
+when possible.  Functions with no `await` blocks are passed through
 unmolested.  Similarly, blocks within tamed functions that don't call
-`twait` can also pass through.
+`await` can also pass through.
 
 Another concern is that the use of tail recursion in translated loops
 might overflow the runtime callstack.  That is certainly true for
 programs like the following:
 
 ```javascript
-while (true) { twait { i++; } }
+while (true) { await { i++; } }
 ```
 
 ...but you should never write programs like these!  That is, there's no
-reason to have a `twait` block unless your program needs to wait for
+reason to have a `await` block unless your program needs to wait for
 some asynchronous event, like a timer fired, a packet arrival, or a 
 user action.  Programs like these:
 
 ```javascript
-while (true) { twait { setTimeout (mkevent (), 1); i++; } }
+while (true) { await { setTimeout (defer (), 1); i++; } }
 ```
 
 will **not** overflow the runtime stack, since the stack is unwound every
 iteration through the loop (via `setTimeout`). And these are the types
-of programs that you should be using `twait` for.
+of programs that you should be using `await` for.
 
 ToDos
 ------
 See the github issue tracker for the more immediate issues.
 
 * Documentation
-     * Change mkevent to something else?
+     * Change defer to something else?
 * Optimizations
-     * Can passThrough blocks in a tamed function that don't have twaits,
+     * Can passThrough blocks in a tamed function that don't have awaits,
 so can get more aggressive here --- in progress, but can still
 seek out some more optimizations....
 * Parsing
diff --git a/lib/ast.js b/lib/ast.js
index 9444fdf..29370ec 100644
--- a/lib/ast.js
+++ b/lib/ast.js
@@ -52,21 +52,21 @@ function Node (startLine) {
     
     //----------------------------------------
 
-    this._hasTwaitStatement = -1;
-    this.hasTwaitStatement = function () {
-	if (this._hasTwaitStatement >= 0) {
-	    return this._hasTwaitStatement;
+    this._hasAwaitStatement = -1;
+    this.hasAwaitStatement = function () {
+	if (this._hasAwaitStatement >= 0) {
+	    return this._hasAwaitStatement;
 	}
 
 	var v = this.getChildren ();
 	var ret = 0;
 	for (i in v) {
-	    if (v[i].hasTwaitStatement ()) {
+	    if (v[i].hasAwaitStatement ()) {
 		ret = 1;
 		break;
 	    }
 	}
-	this._hasTwaitStatement = ret;
+	this._hasAwaitStatement = ret;
 	return ret;
     };
 
@@ -96,7 +96,7 @@ function Node (startLine) {
 
 	var ret = null;
 
-	if (!this.hasTwaitStatement ()) {
+	if (!this.hasAwaitStatement ()) {
 	    var fn = eng.fnFresh ();
 	    ret = eng.Output (fn);
 	    ret.addLambda (fn);
@@ -117,7 +117,7 @@ function Node (startLine) {
 
 //-----------------------------------------------------------------------
 
-function MkeventExpr (startLine, slotList) {
+function PlegeExpr (startLine, slotList) {
     var that = new Node (startLine);
     that._slotList = slotList;
     that._id = 0;
@@ -130,7 +130,7 @@ function MkeventExpr (startLine, slotList) {
     //-----------------------------------------
 
     that.dump = function () {
-	return { type : "mkevent",
+	return { type : "defer",
 		 slots : this._slotList.map (
 		     function (x) { return x.dump () })
 	       };
@@ -162,7 +162,7 @@ function MkeventExpr (startLine, slotList) {
     that.compile = function (eng) {
 	var ret = new eng.Output ();
 	if (this._slotList.length) {
-	    ret.addLine (ret.twaitEv () + ".mkevent (function (args) {");
+	    ret.addLine (ret.awaitEv () + ".defer (function (args) {");
 	    ret.indent ();
 	    for (var i in this._slotList) {
 		var slot = this._slotList[i];
@@ -179,7 +179,7 @@ function MkeventExpr (startLine, slotList) {
 	    ret.unindent ();
 	    ret.addLine ("})");
 	} else {
-	    ret.addLine (ret.twaitEv () + ".mkevent ()");
+	    ret.addLine (ret.awaitEv () + ".defer ()");
 	}
 	return ret;
     };
@@ -614,7 +614,7 @@ function ForStatement (startLine, forIter, body) {
     that.compile = function (eng) {
 
 	// Optimization --- pass through conversion if there
-	// is no twait-related stuff 
+	// is no await-related stuff 
 	var ss = this.cpsShortCircuit (eng);
 	if (ss) { 
 	    return ss; 
@@ -1103,7 +1103,7 @@ function FunctionDeclaration (startLine, name, params, body) {
 
     // Don't propogate down, since we don't need to tame the
     // surrounding block when the inner block is tamed. 
-    that.hasTwaitStatement = function () { return false; };
+    that.hasAwaitStatement = function () { return false; };
 
     //-----------------------------------------
 
@@ -1125,7 +1125,7 @@ function FunctionDeclaration (startLine, name, params, body) {
 	ret.addLine ("function " + nm + " (" + pl + ") {");
 	ret.indent ();
 	var bod;
-	if (this._body.hasTwaitStatement ()) {
+	if (this._body.hasAwaitStatement ()) {
 	    ret.addLine("var __tame_this = this;");
 	    bod = this._body.compile (eng, null, true);
 	    ret.addOutput (bod);
@@ -1148,10 +1148,10 @@ function FunctionDeclaration (startLine, name, params, body) {
 //=======================================================================
 
 
-function TwaitStatement (startLine, body) {
+function AwaitStatement (startLine, body) {
     var that = new Node (startLine);
     that._body = body;
-    that.hasTwaitStatement = function () { return true; };
+    that.hasAwaitStatement = function () { return true; };
 
     //-----------------------------------------
 
@@ -1160,7 +1160,7 @@ function TwaitStatement (startLine, body) {
     //-----------------------------------------
 
     that.dump = function () {
-	return { type : "TwaitStatement",
+	return { type : "AwaitStatement",
 		 body : this._body.dump () };
     };
 
@@ -1177,7 +1177,7 @@ function TwaitStatement (startLine, body) {
 	}
 
 	ret.addLambda (fn);
-	var ev = ret.twaitEv ();
+	var ev = ret.awaitEv ();
 	ret.addLine ("var " + ev + " = new tame.Event (" 
 		     + ret.genericCont() +");");
 	body = this._body.compile (eng);
@@ -1208,9 +1208,9 @@ function ContinueStatement (startLine, targetLabel) {
 
     //-----------------------------------------
 
-    that.hasTwaitStatement = function () {
+    that.hasAwaitStatement = function () {
 	// pessimistic -- assume all labeled breaks are out of 
-	// twait'ed loops.  we can refine this later.
+	// await'ed loops.  we can refine this later.
 	var ret = false;
 	if (this._targetLabel) { ret = true; }
 	return ret;
@@ -1247,9 +1247,9 @@ function BreakStatement (startLine, targetLabel) {
 
     //-----------------------------------------
 
-    that.hasTwaitStatement = function () {
+    that.hasAwaitStatement = function () {
 	// pessimistic -- assume all labeled breaks are out of 
-	// twait'ed loops.  we can refine this later.
+	// await'ed loops.  we can refine this later.
 	var ret = false;
 	if (this._targetLabel) { ret = true; }
 	return ret;
@@ -1298,7 +1298,7 @@ function DoWhileStatement (startLine, condExpr, body) {
     that.compile = function (eng) {
 
 	// Optimization --- pass through conversion if there
-	// is no twait-related stuff 
+	// is no await-related stuff 
 	var ss = this.cpsShortCircuit (eng);
 	if (ss) { 
 	    return ss; 
@@ -1394,7 +1394,7 @@ function WhileStatement (startLine, condExpr, body) {
     that.compile = function (eng) {
 
 	// Optimization --- pass through conversion if there
-	// is no twait-related stuff 
+	// is no await-related stuff 
 	var ss = this.cpsShortCircuit (eng);
 	if (ss) { 
 	    return ss; 
@@ -1700,7 +1700,7 @@ exports.WhileStatement = WhileStatement;
 exports.IfElseStatement = IfElseStatement;
 exports.Expr = Expr;
 exports.Block = Block;
-exports.TwaitStatement = TwaitStatement;
+exports.AwaitStatement = AwaitStatement;
 exports.ForStatement = ForStatement;
 exports.FunctionDeclaration = FunctionDeclaration;
 exports.ReturnStatement = ReturnStatement;
@@ -1716,6 +1716,6 @@ exports.SwitchStatement = SwitchStatement;
 exports.TryStatement = TryStatement;
 exports.CatchStatement = CatchStatement;
 exports.ThisExpr = ThisExpr;
-exports.MkeventExpr = MkeventExpr;
+exports.PlegeExpr = PlegeExpr;
 exports.DoWhileStatement = DoWhileStatement;
 exports.WithStatement = WithStatement;
diff --git a/lib/connectors.tjs b/lib/connectors.tjs
index 4f9be14..5aea2b1 100644
--- a/lib/connectors.tjs
+++ b/lib/connectors.tjs
@@ -6,7 +6,7 @@ function _timeout (cb, t, res, tmp) {
     var arr = [];
     tmp[0] = rv.mkev (true, arr);
     setTimeout (rv.mkev (false), t);
-    twait { rv.wait (mkevent (var which)); }
+    await { rv.wait (defer (var which)); }
     if (res) { res[0] = which; }
     cb.apply (null, arr);
 };
diff --git a/lib/engine.js b/lib/engine.js
index 2024be5..7796674 100644
--- a/lib/engine.js
+++ b/lib/engine.js
@@ -148,7 +148,7 @@ function Output (fnName, startLine) {
 
     this.kBreak = function () { return "k_break"; } ;
     this.kContinue = function () { return "k_continue"; } ;
-    this.twaitEv = function () { return "__tame_ev"; }
+    this.awaitEv = function () { return "__tame_ev"; }
     this.endFn = endFn;
 
     //----------------------------------------
diff --git a/lib/lexer.l b/lib/lexer.l
index 7a798b6..6fa1c3c 100644
--- a/lib/lexer.l
+++ b/lib/lexer.l
@@ -17,9 +17,9 @@
 <INITIAL>"else"		return 'ELSE';
 <INITIAL>"try"		return 'TRY';
 <INITIAL>"catch"	return 'CATCH';
-<INITIAL>"twait"	return 'TWAIT';
+<INITIAL>"await"	return 'AWAIT';
 <INITIAL>"function"	return 'FUNCTION';
-<INITIAL>"mkevent"	return 'MKEVENT';
+<INITIAL>"defer"	return 'PROMISE';
 <INITIAL>"finally"	return 'FINALLY';
 <INITIAL>"case"		return 'CASE';
 <INITIAL>"switch"	return 'SWITCH';
diff --git a/lib/parser.js b/lib/parser.js
index 85a1d0e..580e27e 100644
--- a/lib/parser.js
+++ b/lib/parser.js
@@ -2,8 +2,8 @@
 var parser = (function(){
 var parser = {trace: function trace() { },
 yy: {},
-symbols_: {"error":2,"String":3,"String1":4,"String2":5,"QUOTE1":6,"StringAtoms":7,"QUOTE2":8,"StringAtom":9,"STRING_ATOM":10,"InnerExprAtom":11,"OuterExprAtom":12,"LABEL":13,"BraceExpr":14,"FunctionDeclaration":15,"InnerExprAtomList":16,"InnerExpr":17,"ParenExpr":18,"LPAREN":19,"RPAREN":20,"BracketExpr":21,"LBRACKET":22,"RBRACKET":23,"LBRACE":24,"RBRACE":25,"GENERIC":26,"COMMA":27,"COLON":28,"ID":29,"THIS":30,"Mkevent":31,"SlotAtom":32,"SlotAtomList":33,"Slot":34,"MKEVENT":35,"SlotListOpt":36,"SlotList":37,"Expr":38,"ExprStatement":39,"SEMICOLON":40,"Statement":41,"Block":42,"ForStatement":43,"WhileStatement":44,"DoWhileStatement":45,"IfStatement":46,"TwaitStatement":47,"LabeledStatement":48,"ReturnStatement":49,"BreakStatement":50,"ContinueStatement":51,"SwitchStatement":52,"TryStatement":53,"WithStatement":54,"Label":55,"TRY":56,"CatchStatementOpt":57,"FinallyStatementOpt":58,"CATCH":59,"FINALLY":60,"RETURN":61,"CONTINUE":62,"IdOpt":63,"BREAK":64,"WITH":65,"SourceElements":66,"FOR":67,"ForIter":68,"DO":69,"WHILE":70,"SWITCH":71,"CaseBlock":72,"Case":73,"CaseLabel":74,"CaseBody":75,"DEFAULT":76,"CASE":77,"IF":78,"ELSE":79,"FUNCTION":80,"ParamListOpt":81,"TWAIT":82,"ParamList":83,"Param":84,"FunctionBody":85,"ShbangOpt":86,"SHBANG":87,"Program":88,"$accept":0,"$end":1},
-terminals_: {2:"error",6:"QUOTE1",8:"QUOTE2",10:"STRING_ATOM",13:"LABEL",19:"LPAREN",20:"RPAREN",22:"LBRACKET",23:"RBRACKET",24:"LBRACE",25:"RBRACE",26:"GENERIC",27:"COMMA",28:"COLON",29:"ID",30:"THIS",35:"MKEVENT",40:"SEMICOLON",45:"DoWhileStatement",56:"TRY",59:"CATCH",60:"FINALLY",61:"RETURN",62:"CONTINUE",64:"BREAK",65:"WITH",67:"FOR",69:"DO",70:"WHILE",71:"SWITCH",76:"DEFAULT",77:"CASE",78:"IF",79:"ELSE",80:"FUNCTION",82:"TWAIT",87:"SHBANG"},
+symbols_: {"error":2,"String":3,"String1":4,"String2":5,"QUOTE1":6,"StringAtoms":7,"QUOTE2":8,"StringAtom":9,"STRING_ATOM":10,"InnerExprAtom":11,"OuterExprAtom":12,"LABEL":13,"BraceExpr":14,"FunctionDeclaration":15,"InnerExprAtomList":16,"InnerExpr":17,"ParenExpr":18,"LPAREN":19,"RPAREN":20,"BracketExpr":21,"LBRACKET":22,"RBRACKET":23,"LBRACE":24,"RBRACE":25,"GENERIC":26,"COMMA":27,"COLON":28,"ID":29,"THIS":30,"Plege":31,"SlotAtom":32,"SlotAtomList":33,"Slot":34,"PROMISE":35,"SlotListOpt":36,"SlotList":37,"Expr":38,"ExprStatement":39,"SEMICOLON":40,"Statement":41,"Block":42,"ForStatement":43,"WhileStatement":44,"DoWhileStatement":45,"IfStatement":46,"AwaitStatement":47,"LabeledStatement":48,"ReturnStatement":49,"BreakStatement":50,"ContinueStatement":51,"SwitchStatement":52,"TryStatement":53,"WithStatement":54,"Label":55,"TRY":56,"CatchStatementOpt":57,"FinallyStatementOpt":58,"CATCH":59,"FINALLY":60,"RETURN":61,"CONTINUE":62,"IdOpt":63,"BREAK":64,"WITH":65,"SourceElements":66,"FOR":67,"ForIter":68,"DO":69,"WHILE":70,"SWITCH":71,"CaseBlock":72,"Case":73,"CaseLabel":74,"CaseBody":75,"DEFAULT":76,"CASE":77,"IF":78,"ELSE":79,"FUNCTION":80,"ParamListOpt":81,"AWAIT":82,"ParamList":83,"Param":84,"FunctionBody":85,"ShbangOpt":86,"SHBANG":87,"Program":88,"$accept":0,"$end":1},
+terminals_: {2:"error",6:"QUOTE1",8:"QUOTE2",10:"STRING_ATOM",13:"LABEL",19:"LPAREN",20:"RPAREN",22:"LBRACKET",23:"RBRACKET",24:"LBRACE",25:"RBRACE",26:"GENERIC",27:"COMMA",28:"COLON",29:"ID",30:"THIS",35:"PROMISE",40:"SEMICOLON",45:"DoWhileStatement",56:"TRY",59:"CATCH",60:"FINALLY",61:"RETURN",62:"CONTINUE",64:"BREAK",65:"WITH",67:"FOR",69:"DO",70:"WHILE",71:"SWITCH",76:"DEFAULT",77:"CASE",78:"IF",79:"ELSE",80:"FUNCTION",82:"AWAIT",87:"SHBANG"},
 productions_: [0,[3,1],[3,1],[4,3],[5,3],[9,1],[7,0],[7,2],[11,1],[11,1],[11,1],[11,1],[16,0],[16,2],[17,1],[18,3],[21,3],[14,3],[12,1],[12,1],[12,1],[12,1],[12,1],[12,1],[12,1],[12,1],[12,1],[32,1],[32,1],[32,1],[32,1],[32,1],[32,1],[32,1],[32,1],[32,1],[32,1],[32,1],[33,1],[33,2],[34,1],[31,4],[36,0],[36,1],[37,1],[37,3],[38,0],[38,2],[39,2],[39,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[55,1],[48,2],[53,4],[57,0],[57,5],[58,0],[58,2],[49,3],[51,3],[50,3],[54,5],[42,3],[66,0],[66,2],[43,5],[44,6],[44,5],[52,7],[72,0],[72,2],[73,2],[74,2],[74,2],[74,3],[75,1],[46,5],[46,7],[68,5],[68,1],[15,6],[47,2],[63,0],[63,1],[83,1],[83,3],[84,1],[81,0],[81,1],[85,1],[86,0],[86,1],[88,2]],
 performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {
 
@@ -105,7 +105,7 @@ break;
 case 40: this.$ = new yy.Expr ($$[$0]);  
 break;
 case 41:
-           this.$ = new yy.MkeventExpr (_$[$0-3].first_line, $$[$0-1]);
+           this.$ = new yy.PlegeExpr (_$[$0-3].first_line, $$[$0-1]);
      
 break;
 case 42: this.$ = []; 
@@ -237,7 +237,7 @@ case 93:
      
 break;
 case 94:
-        this.$ = new yy.TwaitStatement (_$[$0-1].first_line, $$[$0]);
+        this.$ = new yy.AwaitStatement (_$[$0-1].first_line, $$[$0]);
      
 break;
 case 96: this.$ = yytext; 
@@ -667,7 +667,7 @@ case 49:return 'ENDOFFILE';
 break;
 }
 };
-lexer.rules = [/^\/\/.*/,/^\s+/,/^for\b/,/^while\b/,/^break\b/,/^continue\b/,/^return\b/,/^do\b/,/^if\b/,/^else\b/,/^try\b/,/^catch\b/,/^twait\b/,/^function\b/,/^mkevent\b/,/^finally\b/,/^case\b/,/^switch\b/,/^default\b/,/^this\b/,/^with\b/,/^#![ ]*[/].*/,/^[a-zA-Z_0-9]+[ ^]*[:]/,/^[a-zA-Z_][a-zA-Z_0-9]*/,/^\{/,/^\}/,/^\(/,/^\)/,/^\[/,/^\]/,/^;/,/^,/,/^:/,/^"/,/^'/,/^\/\*/,/^[^/{}()\[\];,:"'\s]+/,/^./,/^\\./,/^[^\\"]+/,/^"/,/^$/,/^\\./,/^[^\\']+/,/^'/,/^$/,/^\*\//,/^\*/,/^[^*]+/,/^$/];
+lexer.rules = [/^\/\/.*/,/^\s+/,/^for\b/,/^while\b/,/^break\b/,/^continue\b/,/^return\b/,/^do\b/,/^if\b/,/^else\b/,/^try\b/,/^catch\b/,/^await\b/,/^function\b/,/^defer\b/,/^finally\b/,/^case\b/,/^switch\b/,/^default\b/,/^this\b/,/^with\b/,/^#![ ]*[/].*/,/^[a-zA-Z_0-9]+[ ^]*[:]/,/^[a-zA-Z_][a-zA-Z_0-9]*/,/^\{/,/^\}/,/^\(/,/^\)/,/^\[/,/^\]/,/^;/,/^,/,/^:/,/^"/,/^'/,/^\/\*/,/^[^/{}()\[\];,:"'\s]+/,/^./,/^\\./,/^[^\\"]+/,/^"/,/^$/,/^\\./,/^[^\\']+/,/^'/,/^$/,/^\*\//,/^\*/,/^[^*]+/,/^$/];
 lexer.conditions = {"ST_QUOTE2":{"rules":[38,39,40,41],"inclusive":true},"ST_QUOTE1":{"rules":[42,43,44,45],"inclusive":true},"ST_COMMENT":{"rules":[46,47,48,49],"inclusive":true},"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37],"inclusive":true}};return lexer;})()
 parser.lexer = lexer;
 return parser;
diff --git a/lib/parser.y b/lib/parser.y
index acf409e..71c4b92 100644
--- a/lib/parser.y
+++ b/lib/parser.y
@@ -102,7 +102,7 @@ OuterExprAtom
      | ParenExpr   { $$ = $1; } 
      | BracketExpr { $$ = $1; }
      | THIS        { $$ = [ new yy.ThisExpr (@1.first_line) ]; }
-     | Mkevent     { $$ = [ $1 ]; }
+     | Plege     { $$ = [ $1 ]; }
      ;
 
 SlotAtom
@@ -113,7 +113,7 @@ SlotAtom
      | ParenExpr   { $$ = $1; } 
      | BracketExpr { $$ = $1; }
      | THIS        { $$ = [ new yy.ThisExpr (@1.first_line) ]; }
-     | Mkevent     { $$ = [ $1 ]; }
+     | Plege     { $$ = [ $1 ]; }
      | LABEL       { $$ = [ new yy.Atom (@1.first_line, yytext + " :")]; }
      | BraceExpr   { $$ = $1; }
      | FunctionDeclaration { $$ = [ $1 ]; }
@@ -129,10 +129,10 @@ Slot
      ;
      
 
-Mkevent
-     : MKEVENT LPAREN SlotListOpt RPAREN
+Plege
+     : PROMISE LPAREN SlotListOpt RPAREN
      {
-           $$ = new yy.MkeventExpr (@1.first_line, $3);
+           $$ = new yy.PlegeExpr (@1.first_line, $3);
      }
      ;
 
@@ -178,7 +178,7 @@ Statement
      | WhileStatement
      | DoWhileStatement
      | IfStatement
-     | TwaitStatement
+     | AwaitStatement
      | LabeledStatement
      | ReturnStatement
      | BreakStatement
@@ -345,10 +345,10 @@ FunctionDeclaration
      }
      ;
 
-TwaitStatement
-     : TWAIT Statement
+AwaitStatement
+     : AWAIT Statement
      {
-        $$ = new yy.TwaitStatement (@1.first_line, $2);
+        $$ = new yy.AwaitStatement (@1.first_line, $2);
      }
      ;
 
diff --git a/lib/runtime.js b/lib/runtime.js
index 13aaaa4..9f01196 100644
--- a/lib/runtime.js
+++ b/lib/runtime.js
@@ -59,7 +59,7 @@ function Rendezvous () {
     //==================================================
 
     // The public interface has two methods --- mkev, and wait.
-    // We don't call it mkevent, so as not to use a keyword. 
+    // We don't call it defer, so as not to use a keyword. 
     // Also note that variadic return is the only possibility here.
 
     this.mkev = function (id, dest) {
@@ -123,7 +123,7 @@ function Event (k) {
 	    this._continuation ();
 	}
     };
-    this.mkevent = function (assign_fn) {
+    this.defer = function (assign_fn) {
 	this._count++;
 	var x = this;
 	return (function () { 
diff --git a/notes/CPS-rules.js b/notes/CPS-rules.js
index 13a6000..e552f7a 100644
--- a/notes/CPS-rules.js
+++ b/notes/CPS-rules.js
@@ -22,7 +22,7 @@ CPS[ l : while (e) { b }  ] = function (k) {
 
 // See event.js for what the event does.  It's a pure-javascript
 // doo-hickey.
-CPS[ twait { b } k ] = {
+CPS[ await { b } k ] = {
     var __ev = new Event ();
     var __f1 = CPS[b];
     var __f2 = CPS[k];
diff --git a/test/cases/1.tjs b/test/cases/1.tjs
index 71a93f8..5bf6a72 100644
--- a/test/cases/1.tjs
+++ b/test/cases/1.tjs
@@ -10,7 +10,7 @@ exports["rendezvous & windowing example"] = {
 	
 	function call (i, ev) {
 	    slots[i] = 1;
-	    twait { setTimeout (mkevent (), 10*Math.random()); }
+	    await { setTimeout (defer (), 10*Math.random()); }
 	    slots[i] |= 2;
 	    ev();
 	};
@@ -28,7 +28,7 @@ exports["rendezvous & windowing example"] = {
 		        nsent++;
 		    } else {
 		        var res;
-		        twait { rv.wait (mkevent (res)); }
+		        await { rv.wait (defer (res)); }
 		        slots[res] |= 4;
 		        nrecv++;
 		    }
@@ -37,7 +37,7 @@ exports["rendezvous & windowing example"] = {
 	};
 	    
 	    var n = 100;
-	    twait { window (n, 10, mkevent ()); }
+	    await { window (n, 10, defer ()); }
 	    ev ();
     },
 	
diff --git a/test/cases/10.tjs b/test/cases/10.tjs
index 56c61a0..c07968b 100644
--- a/test/cases/10.tjs
+++ b/test/cases/10.tjs
@@ -4,7 +4,7 @@ var assert = require ("assert");
 var res = 0;
 
 function foo (cb) {
-    twait { setTimeout (mkevent (), 10 * Math.random ()); }
+    await { setTimeout (defer (), 10 * Math.random ()); }
     res++;
     cb();
 };
@@ -12,7 +12,7 @@ function foo (cb) {
 exports["parser variations"] = {
 
     run : function (cb) {
-	    if (true) twait foo (mkevent ());
+	    if (true) await foo (defer ());
 	    res++;
 	    cb();
     },
diff --git a/test/cases/11.tjs b/test/cases/11.tjs
index 6265ad8..3e0b26b 100644
--- a/test/cases/11.tjs
+++ b/test/cases/11.tjs
@@ -10,7 +10,7 @@ exports["another test of continue and break"] = {
 
 	foo : while (i < 100) {
 
-	    twait { setTimeout (mkevent (), 10*Math.random()); }
+	    await { setTimeout (defer (), 10*Math.random()); }
 	    
 	    if (i == 10) {
 		i += 2;
diff --git a/test/cases/12.tjs b/test/cases/12.tjs
index fd09bff..d8eaf85 100644
--- a/test/cases/12.tjs
+++ b/test/cases/12.tjs
@@ -8,7 +8,7 @@ exports["a test of return"] = {
     run : function (cb) {
 	
 	while (i < n + 4) {
-	    twait { setTimeout (mkevent (), 10 * Math.random ()); }
+	    await { setTimeout (defer (), 10 * Math.random ()); }
 	    i++;
 	    if (i == n) {
 		cb ();
diff --git a/test/cases/13.tjs b/test/cases/13.tjs
index 557d0c3..dce979b 100644
--- a/test/cases/13.tjs
+++ b/test/cases/13.tjs
@@ -10,7 +10,7 @@ exports["passThrough/compile test"] = {
             for (var i = 0; i < 100; i++);
             var d = { cat : function (n, cb) {
                 for (var i = 0; i < n; i++) {
-                    twait { setTimeout (mkevent (), 5 * Math.random ()); }
+                    await { setTimeout (defer (), 5 * Math.random ()); }
                 }
                 cb ();
             }, n : 10 };
@@ -19,7 +19,7 @@ exports["passThrough/compile test"] = {
         };
 
         var d = make_dict ();
-        twait { d.cat (d.n, mkevent ()); }
+        await { d.cat (d.n, defer ()); }
         ok = true;
         cb ();
     },
diff --git a/test/cases/14.tjs b/test/cases/14.tjs
index e982774..c425711 100644
--- a/test/cases/14.tjs
+++ b/test/cases/14.tjs
@@ -13,7 +13,7 @@ function MyClass (lim) {
         if (this._i >= this._lim) {
             done = true;
         } else {
-            twait { setTimeout (mkevent (), 3 * Math.random ()); }
+            await { setTimeout (defer (), 3 * Math.random ()); }
             this._i ++;
         }
         cb (done);
@@ -30,7 +30,7 @@ exports["test of 'this' inside of a tamed class"] = {
         var go = true;
         while (go) {
             var res = [];
-            twait { obj.next (mkevent (res)); }
+            await { obj.next (defer (res)); }
             go = !res[0];
         }
         cb ();
diff --git a/test/cases/16.tjs b/test/cases/16.tjs
index 2bcc6f6..6430114 100644
--- a/test/cases/16.tjs
+++ b/test/cases/16.tjs
@@ -14,7 +14,7 @@ function Class () {
         this._u = [];
         for (var i in this._v) {
             this._u.push (this._v[i]);
-            twait { setTimeout (mkevent (), 10*Math.random ()); }
+            await { setTimeout (defer (), 10*Math.random ()); }
         }
         cb ();
     };
@@ -30,7 +30,7 @@ var obj = new Class ();
 exports["a test of for (var i in this._foo)"] = { 
 
     run : function (cb) {
-        twait { obj.run (mkevent ()); }
+        await { obj.run (defer ()); }
         cb ();
     },
 
diff --git a/test/cases/17.tjs b/test/cases/17.tjs
index 14d3be8..f742ba5 100644
--- a/test/cases/17.tjs
+++ b/test/cases/17.tjs
@@ -5,7 +5,7 @@ var res = 0;
 var i = 0;
 
 function foo (i, cb) {
-    twait { setTimeout (mkevent (), i); }
+    await { setTimeout (defer (), i); }
     cb (i);
 };
 
@@ -18,14 +18,14 @@ exports["a test of fulfill values"] = {
         
         for (var i = 0; i < 20; i++) {
             var x = 3 * Math.random ();
-            twait { foo (x, mkevent (var y, z)); }
+            await { foo (x, defer (var y, z)); }
             if (x != y) { ok = false; }
         }
         
         for (var i = 0; i < 20; i++) {
             var x = 3 * Math.random ();
             var res = [];
-            twait { foo (x, mkevent (res)); }
+            await { foo (x, defer (res)); }
             if (x != res[0]) { ok = false; }
         }
         
diff --git a/test/cases/18.tjs b/test/cases/18.tjs
index 9312be4..b2e435b 100644
--- a/test/cases/18.tjs
+++ b/test/cases/18.tjs
@@ -9,9 +9,9 @@ exports["test do..while..."] = {
     run : function (cb) {
 	    var i = 0;	
 	    do {
-	        twait { 
-		        setTimeout (mkevent (), 1); 
-		        setTimeout (mkevent (), 2); 
+	        await { 
+		        setTimeout (defer (), 1); 
+		        setTimeout (defer (), 2); 
 	        }
 	        slots[i] = 1;
 	        i++;
diff --git a/test/cases/19.tjs b/test/cases/19.tjs
index 3f99878..6c493f1 100644
--- a/test/cases/19.tjs
+++ b/test/cases/19.tjs
@@ -11,8 +11,8 @@ exports["test with{} statements"] = {
 
         with (env) {
             while (i < n) {
-	            twait { 
-		            setTimeout (mkevent (), 3*Math.random ()); 
+	            await { 
+		            setTimeout (defer (), 3*Math.random ()); 
                 }
                 sum += i;
                 i++;
diff --git a/test/cases/2.tjs b/test/cases/2.tjs
index 86cd0f0..f072a63 100644
--- a/test/cases/2.tjs
+++ b/test/cases/2.tjs
@@ -4,14 +4,14 @@ var slots = {};
 var n = 40;
 var assert = require ("assert");
 
-exports["simple parallel twait"] = {
+exports["simple parallel await"] = {
     
     run : function (cb) {
 	    var i = 0;	
 	    while (i < n) {
-	        twait { 
-		        setTimeout (mkevent (), 1); 
-		        setTimeout (mkevent (), 2); 
+	        await { 
+		        setTimeout (defer (), 1); 
+		        setTimeout (defer (), 2); 
 	        }
 	        slots[i] = 1;
 	        i++;
diff --git a/test/cases/20.tjs b/test/cases/20.tjs
index a0e879c..a2b9c7a 100644
--- a/test/cases/20.tjs
+++ b/test/cases/20.tjs
@@ -10,15 +10,15 @@ exports["test nested serial/parallel"] = {
     
     run : function (cb) {
 
-        twait {
+        await {
             for (var i = 0; i < n; i++) {
                 (function (cb) {
                     var my_i = i;
-                    twait { setTimeout (mkevent (), 5*Math.random ()); }
-                    twait { setTimeout (mkevent (), 4*Math.random ()); }
+                    await { setTimeout (defer (), 5*Math.random ()); }
+                    await { setTimeout (defer (), 4*Math.random ()); }
                     slots[my_i] = true;
                     cb();
-                })(mkevent ());
+                })(defer ());
             }
         }
 	    cb();
diff --git a/test/cases/21.tjs b/test/cases/21.tjs
index ce95a27..aa55413 100644
--- a/test/cases/21.tjs
+++ b/test/cases/21.tjs
@@ -4,11 +4,11 @@ var slots = {};
 var n = 10;
 var assert = require ("assert");
 
-exports["test twait with no curlies"] = {
+exports["test await with no curlies"] = {
     
     run : function (cb) {
         for (var i = 0; i < n; i++) {
-            twait setTimeout (mkevent (), 3 * Math.random ());
+            await setTimeout (defer (), 3 * Math.random ());
             slots[i] = 1;
         }
 	    cb();
diff --git a/test/cases/22.tjs b/test/cases/22.tjs
index 5085846..3604abe 100644
--- a/test/cases/22.tjs
+++ b/test/cases/22.tjs
@@ -10,7 +10,7 @@ var results = [];
 var animals = [];
 
 function slowGuy (tm, str, cb) {
-    twait { setTimeout (mkevent (), tm); }
+    await { setTimeout (defer (), tm); }
     cb (str);
 };
 
@@ -19,16 +19,16 @@ exports["test timeout connectors"] = {
     run : function (cb) {
 	var info = [];
 
-	twait { 
+	await { 
 	    slowGuy (1, "dog",
-		     connectors.timeout (mkevent (animals[0]), 100, info));
+		     connectors.timeout (defer (animals[0]), 100, info));
 	}
 	results[0] = info[0];
 
 	animals[1];
-	twait { 
+	await { 
 	    slowGuy (100, "cat",
-		     connectors.timeout (mkevent (animals[1]), 1, info));
+		     connectors.timeout (defer (animals[1]), 1, info));
 	}
 	results[1] = !info[1];
 	cb();
diff --git a/test/cases/3.tjs b/test/cases/3.tjs
index 2dc86a5..8f77571 100644
--- a/test/cases/3.tjs
+++ b/test/cases/3.tjs
@@ -10,7 +10,7 @@ exports["break and continue"] = {
 	    var i = 0;
 	    while (1) {
 	        slots[i] = 0;
-	        twait { setTimeout (mkevent (), 1); }
+	        await { setTimeout (defer (), 1); }
             
 	        if (i == skip) {
 		        i++;
diff --git a/test/cases/4.tjs b/test/cases/4.tjs
index cc3ac75..f6f594d 100644
--- a/test/cases/4.tjs
+++ b/test/cases/4.tjs
@@ -10,7 +10,7 @@ exports["break and continue"] = {
 	    var i = 0;
 	    foo : while (1) {
 	        slots[i] = 0;
-	        twait { setTimeout (mkevent (), 1); }
+	        await { setTimeout (defer (), 1); }
             
 	        if (i == skip) {
 		        i++;
diff --git a/test/cases/5.tjs b/test/cases/5.tjs
index 7f0056b..b7b05fa 100644
--- a/test/cases/5.tjs
+++ b/test/cases/5.tjs
@@ -10,7 +10,7 @@ exports["break and continue"] = {
 	    var i = 0;
 	    foo : while (1) {
 	        slots[i] = 0;
-	        twait { setTimeout (mkevent (), 1); }
+	        await { setTimeout (defer (), 1); }
             
 	        for (var j = 0; j < 10; j++) {
 		        if (i == skip) {
diff --git a/test/cases/6.tjs b/test/cases/6.tjs
index 03a0e9c..ccae30e 100644
--- a/test/cases/6.tjs
+++ b/test/cases/6.tjs
@@ -4,7 +4,7 @@ var assert = require ("assert");
 var results = [];
 
 function blah (ev) { 
-    twait { setTimeout (mkevent (), 10*Math.random ()); }
+    await { setTimeout (defer (), 10*Math.random ()); }
     ev(); 
 };
 
@@ -12,23 +12,23 @@ function runsw (x, cb) {
     
     switch (x) {
     case 0:
-	    twait { blah (mkevent ()); }
+	    await { blah (defer ()); }
 	    results.push (0);
 	    break;
     case 17:
     case 1:
-	    twait { blah (mkevent ()); }
+	    await { blah (defer ()); }
 	    results.push (1);
 	    break;
     case 2:
-	    twait { blah (mkevent ()); }
+	    await { blah (defer ()); }
 	    results.push (2);
     case 18:
     case 3:
-	    twait { blah (mkevent ()); }
+	    await { blah (defer ()); }
 	    results.push (3);
     default:
-	    twait { blah (mkevent ()); }
+	    await { blah (defer ()); }
 	    results.push (4);
 	    break;
     }
@@ -40,7 +40,7 @@ exports["switch & case statement"] = {
     run : function (cb) {
 	    var lst = [ 0, 1, 2, 3, 4, 18, 17];
 	    for (var i in lst) {
-	        twait { runsw (lst[i], mkevent ()); }
+	        await { runsw (lst[i], defer ()); }
 	    }
 	    cb ();
     },
diff --git a/test/cases/7.tjs b/test/cases/7.tjs
index a07b5f0..f53870f 100644
--- a/test/cases/7.tjs
+++ b/test/cases/7.tjs
@@ -7,7 +7,7 @@ exports["for..in iteration"] = {
 
     run : function (cb) {
 	    for (var animal in inlist) {
-	        twait { setTimeout (mkevent (), 10 * Math.random ()); }
+	        await { setTimeout (defer (), 10 * Math.random ()); }
 	        outlist.push (inlist[animal]);
 	    }
 	    cb ();
diff --git a/test/cases/8.tjs b/test/cases/8.tjs
index 249c9c3..363b856 100644
--- a/test/cases/8.tjs
+++ b/test/cases/8.tjs
@@ -11,7 +11,7 @@ exports["for..in iteration"] = {
         
 	    var i = 0;
 	    for (i = 0; i < 10; i++) {
-	        twait { setTimeout (mkevent (), 10* Math.random ()); }
+	        await { setTimeout (defer (), 10* Math.random ()); }
 	        listA.push (i);
 	    }
 	    for ( ; i < 20; i++) {
@@ -21,7 +21,7 @@ exports["for..in iteration"] = {
 	        if (i >= 30) {
 		        break;
 	        }
-	        twait { setTimeout (mkevent (), 10* Math.random ()); }
+	        await { setTimeout (defer (), 10* Math.random ()); }
 	        listA.push (i);
 	        i++;
 	    }
diff --git a/test/cases/9.tjs b/test/cases/9.tjs
index 1d3352d..991287f 100644
--- a/test/cases/9.tjs
+++ b/test/cases/9.tjs
@@ -4,7 +4,7 @@ var assert = require ("assert");
 var res = 0;
 
 function foo (cb) {
-    twait { setTimeout (mkevent (), 10 * Math.random ()); }
+    await { setTimeout (defer (), 10 * Math.random ()); }
     res++;
     cb();
 };
@@ -12,7 +12,7 @@ function foo (cb) {
 exports["parser variations"] = {
     
     run : function (cb) {
-	    if (true) twait foo (mkevent ());
+	    if (true) await foo (defer ());
 	    res++;
 	    cb();
     },
diff --git a/test/cases/lib/15.tjs b/test/cases/lib/15.tjs
index a732f14..a0261f9 100644
--- a/test/cases/lib/15.tjs
+++ b/test/cases/lib/15.tjs
@@ -12,7 +12,7 @@ function makeTest (exports) {
 	
 	        function call (i, ev) {
 	            slots[i] = 1;
-	            twait { setTimeout (mkevent (), 10*Math.random()); }
+	            await { setTimeout (defer (), 10*Math.random()); }
 	            slots[i] |= 2;
 	            ev();
 	        };
@@ -30,7 +30,7 @@ function makeTest (exports) {
 		                nsent++;
 		            } else {
 		                var res = [];
-		                twait { rv.wait (mkevent (res)); }
+		                await { rv.wait (defer (res)); }
 		                slots[res[0]] |= 4;
 		                nrecv++;
 		            }
@@ -39,7 +39,7 @@ function makeTest (exports) {
 	        };
 	    
 	        var n = 100;
-	        twait { window (n, 10, mkevent ()); }
+	        await { window (n, 10, defer ()); }
 	        ev ();
         },
 	    
diff --git a/test/harness.tjs b/test/harness.tjs
index b3d1caf..b7f1411 100644
--- a/test/harness.tjs
+++ b/test/harness.tjs
@@ -18,7 +18,7 @@ function Case (index, nm, file) {
 	    var ret = true;
 	    var x = require ("../" + this._file);
 	    for (var c in x) {
-	        twait { x[c].run (mkevent ());}
+	        await { x[c].run (defer ());}
 	        try { 
 		        x[c].check ();
 		        console.log (this._nm + ": passed");
@@ -41,11 +41,11 @@ function TamedCase (index, prfx, infile, outfile) {
         var fs = require ('fs');
         var Engine = require ('../lib/engine').Engine;
         var engine = new Engine (this._infile);
-        twait { engine.readInput (mkevent ()); }
+        await { engine.readInput (defer ()); }
 	    engine.parse ();
 	    var outdat = engine.compile ().formatOutput ();
         var res = [];
-        twait { fs.writeFile (this._file, outdat, mkevent (res)); }
+        await { fs.writeFile (this._file, outdat, defer (res)); }
 	    if (res[0]) throw res[0];
         ev();
     };
@@ -63,7 +63,7 @@ function read_cases (ev) {
     var tests = [];
     var res = [];
     var prfx = "test/cases/";
-    twait { fs.readdir ('test/cases/', mkevent (res)); }
+    await { fs.readdir ('test/cases/', defer (res)); }
     var err = res[0];
     var files = res[1];
     if (err) throw err;
@@ -89,15 +89,15 @@ function read_cases (ev) {
 
 function do_cases (ev) {
     var res = [];
-    twait { read_cases (mkevent (res)); }
+    await { read_cases (defer (res)); }
     var cases = res[0];
     var tot = 0;
     var good = 0;
     for (var i in cases) {
-	    twait { cases[i].compile (mkevent ()); }
+	    await { cases[i].compile (defer ()); }
 	    var res = [];
 	    tot++;
-	    twait { cases[i].run (mkevent(res)); }
+	    await { cases[i].run (defer(res)); }
 	    if (res[0]) {
 	        good ++;
 	    }
@@ -110,6 +110,6 @@ function do_cases (ev) {
     ev();
 };
 
-twait { do_cases (mkevent ()); }
+await { do_cases (defer ()); }
 
 
diff --git a/web/index.html b/web/index.html
index 8c8ed7c..54c2ac5 100644
--- a/web/index.html
+++ b/web/index.html
@@ -140,56 +140,56 @@ handleVisit : function(angel, buffy) {
 				<h3>So...how does Tame solve this?</h3>
 <pre class="prettyprint lang-js">
 var res1, res2;
-twait {
-	doOneThing(mkevent(res1));
-	andAnother(mkevent(res2));
+await {
+	doOneThing(defer(res1));
+	andAnother(defer(res2));
 }
 thenDoSomethingWith(res1, res2);
 </pre>
 
 				<p>
-					As shown above, Tame introduces 2 keywords, <span class="code_term">twait</span> and <span class="code_term">mkevent</span> (short for "make event"). They are used in tandem.
+					As shown above, Tame introduces 2 keywords, <span class="code_term">await</span> and <span class="code_term">defer</span> (short for "make event"). They are used in tandem.
 				</p>
 
 				<p>
-					<span class="code_term">twait</span> marks a section of code that depends on externals events, like network or disk activity, or a timer.  
+					<span class="code_term">await</span> marks a section of code that depends on externals events, like network or disk activity, or a timer.  
 					Only once all relevant events
-					inside a <span class="code_term">twait</span> block have finished does control continue past it.
-					<span class="code_term">mkevent</span> lets <span class="code_term">twait</span> know which events to wait for.  <span class="code_term">mkevent</span> 
-					returns an anonymous function that you give to your async functions as a callback.   Such an async function tells <span class="code_term">twait</span> 
-					that the expected event has occurred by calling its <span class="code_term">mkevent</span>-generated callback.
+					inside a <span class="code_term">await</span> block have finished does control continue past it.
+					<span class="code_term">defer</span> lets <span class="code_term">await</span> know which events to wait for.  <span class="code_term">defer</span> 
+					returns an anonymous function that you give to your async functions as a callback.   Such an async function tells <span class="code_term">await</span> 
+					that the expected event has occurred by calling its <span class="code_term">defer</span>-generated callback.
 				</p>
 				<p>
-					If your callback function is supposed to take arguments, name them as arguments to <span class="code_term">mkevent</span>, and they'll
-					be available after the <span class="code_term">twait</span> block completes.
+					If your callback function is supposed to take arguments, name them as arguments to <span class="code_term">defer</span>, and they'll
+					be available after the <span class="code_term">await</span> block completes.
 				</p>
 				<p>
-					(For language geeks: <span class="code_term">twait</span> is the only new addition to JavaScript language semantics here.  It takes the current program
+					(For language geeks: <span class="code_term">await</span> is the only new addition to JavaScript language semantics here.  It takes the current program
 					continuation and stores it in a hidden JavaScript object. 
-					<span class="code_term">mkevent</span> is syntactic sugar that calls into the hidden object. If an event is the last outstanding event 
-					in its parent <span class="code_term">twait</span> block, it reactivates the stored program continuation.)
+					<span class="code_term">defer</span> is syntactic sugar that calls into the hidden object. If an event is the last outstanding event 
+					in its parent <span class="code_term">await</span> block, it reactivates the stored program continuation.)
 				</p>
 				<p>
 					Sound confusing? It's really not when you see it in action. Let's show some example code.
 				</p>
 <pre class="prettyprint lang-js">
 for (var i = 0; i < 10; i++) {
-	twait { setTimeout (mkevent (), 100); }
+	await { setTimeout (defer (), 100); }
 	console.log ("Hello world! " + i);
 }
 </pre>				
 				<p>
 					The above code prints "Hello world" 10 times, separated by 100ms. The code looks and feels like threaded code, but it uses preexisting async-style functions.
 					To be clear: this is the setTimeout you know and love, <i>unmodified</i>. TameJS works with all existing async code.
-					setTimeout is expecting a function to execute, and that's what mkevent() is providing.
+					setTimeout is expecting a function to execute, and that's what defer() is providing.
 				</p>
 				<p>
-					What happens if we put two <span class="code_term">setTimeout</span> calls inside one twait?
+					What happens if we put two <span class="code_term">setTimeout</span> calls inside one await?
 <pre class="prettyprint lang-js">
 for (var i = 0; i < 10; i++) {
-	twait { 
-		setTimeout (mkevent (), 10); 
-		setTimeout (mkevent (), 100); 
+	await { 
+		setTimeout (defer (), 10); 
+		setTimeout (defer (), 100); 
 	}
 	console.log ("Hello world! " + i);
 }
@@ -199,15 +199,15 @@ for (var i = 0; i < 10; i++) {
 					Tame's beauty is starting to unfold here: 2 timers are fired at once, and after both have returned the loop continues. So every
 					100ms it prints "Hello world" and the next number.
 				<p>
-					Moving the twait outside the for loop is acceptable. All 20 timers would fire at once, and this
+					Moving the await outside the for loop is acceptable. All 20 timers would fire at once, and this
 					code would let out your feelings in approximately 100ms:
 				</p>
 <pre class="prettyprint lang-js">
 var message = "I'm starting to get turned on.";
-twait { 
+await { 
 	for (var i = 0; i < 10; i++) {
-		setTimeout (mkevent (), 10); 
-		setTimeout (mkevent (), 100); 
+		setTimeout (defer (), 10); 
+		setTimeout (defer (), 100); 
 	}
 }
 console.log (message);
@@ -216,13 +216,13 @@ console.log (message);
 
 
 				<p>
-					In practice your async functions call back with information, and you want <span class="code_term">mkevent</span> to collect that information.
+					In practice your async functions call back with information, and you want <span class="code_term">defer</span> to collect that information.
 					Let's use Node's <span class="code_term">dns.resolve</span> function:
 				</p>
 <pre class="prettyprint lang-js">
 var err, ip;
-twait { 
-	dns.resolve (host, "A", mkevent (err, ip));
+await { 
+	dns.resolve (host, "A", defer (err, ip));
 }
 if (err) { console.log ("ERROR! " + err); } 
 else { console.log (host + " -> " + ip); }
@@ -230,15 +230,15 @@ else { console.log (host + " -> " + ip); }
 
 				<p>
 					Notice that <span class="code_term">dns.resolve</span> is expecting a third parameter, a function
-					to call with its result. <span class="code_term">mkevent</span> provides a function that collects
+					to call with its result. <span class="code_term">defer</span> provides a function that collects
 					the results into <span class="code_term">err</span> and <span class="code_term">ip</span>.
 				</p>
 				<p>
 					Tame also lets us name those variables inline, for convenience:
 				</p>
 <pre class="prettyprint lang-js">
-twait { 
-	dns.resolve (host, "A", mkevent (var err, ip));
+await { 
+	dns.resolve (host, "A", defer (var err, ip));
 }
 </pre>
 
@@ -251,8 +251,8 @@ twait {
 var dns = require("dns");
 
 function do_one (ev, host) {
-    twait { 
-    	dns.resolve (host, "A", mkevent (var err, ip));
+    await { 
+    	dns.resolve (host, "A", defer (var err, ip));
     }
     if (err) { console.log ("ERROR! " + err); } 
     else { console.log (host + " -> " + ip); }
@@ -260,9 +260,9 @@ function do_one (ev, host) {
 };
 
 function do_all (lst) {
-    twait {
+    await {
         for (var i = 0; i < lst.length; i++) {
-            do_one (mkevent (), lst[i]);
+            do_one (defer (), lst[i]);
         }
     }
 };
@@ -279,13 +279,13 @@ okcupid.com -> 66.59.66.6
 </pre>
 
 				<p>
-					If you want to do these DNS resolutions in serial (rather than parallel), then the change from above is trivial: just switch the order of the twait and for statements above:
+					If you want to do these DNS resolutions in serial (rather than parallel), then the change from above is trivial: just switch the order of the await and for statements above:
 				</p>
 <pre class="prettyprint lang-js">
 function do_all (lst) {
     for (var i = 0; i < lst.length; i++) {
-        twait {
-            do_one (mkevent (), lst[i]);
+        await {
+            do_one (defer (), lst[i]);
         }
     }
 }
@@ -303,10 +303,10 @@ handleVisit : function(angel, buffy) {
 	// let's fire all 3 at once
 	//
 
-	twait {
-		getScore (angel, buffy, mkevent(var score));
-		getNextMatch (angel, buffy, mkevent(var next));
-		recordVisitAndGetInfo (angel, buffy, mkevent(var vinfo));
+	await {
+		getScore (angel, buffy, defer(var score));
+		getNextMatch (angel, buffy, defer(var next));
+		recordVisitAndGetInfo (angel, buffy, defer(var vinfo));
 	}
 
 	//
@@ -366,25 +366,25 @@ huntMen : function(buffy) {
    while (soulmates.length < 10) {
  
       // Get 10 candidates for Buffy  
-      twait {  
-        getMatches(buffy, 10, mkevent(var userids));
+      await {  
+        getMatches(buffy, 10, defer(var userids));
       }
   
       for (var i = 0; i < userids.length; i++) {
         var u = userids[i];
-        twait {
+        await {
           // get their pic from our pic server
-          getThumbnail  (u, mkevent(var thumb));
+          getThumbnail  (u, defer(var thumb));
         }
-        twait {
+        await {
           // ask our pic analyzer to review
-          isPicAVampire(thumb, mkevent(var is_vamp));
+          isPicAVampire(thumb, defer(var is_vamp));
         }
         if (! is_vamp) {
-          twait {
+          await {
             // get 2 more pieces of info
-            getPersonality(u, mkevent(var personality));
-            getLastTalked (u, match, mkevent(var last_talked));
+            getPersonality(u, defer(var personality));
+            getLastTalked (u, match, defer(var last_talked));
           }
           soulmates.push({
             "userid" : match,
@@ -494,7 +494,7 @@ node &lt;outfile&gt; # or whatever you want
 					In Tame it's very simple:
 				</p>
 <pre class="prettyprint lang-js">
-twait fs.readFile (__filename, mkevent (var err, text)); 
+await fs.readFile (__filename, defer (var err, text)); 
 if (err) { throw (err): }
 console.log (text.toUpperCase ());
 </pre>					
@@ -541,9 +541,9 @@ Step(
 					And Tame:
 				</p>
 <pre class="prettyprint lang-js">
-twait { 
-   fs.readFile (__filename, mkevent (var e1, code));
-   fs.readFile ("/etc/password", mkevent (var e2, users)); 
+await { 
+   fs.readFile (__filename, defer (var e1, code));
+   fs.readFile ("/etc/password", defer (var e2, users)); 
 }
 if (e1) throw e1;
 if (e2) throw e2;
@@ -565,7 +565,7 @@ console.log (users);
 				<p class="answer">
 					Yes - it's also a translation of JS and seems to use a similar compilation technique, and we think it's more evidence that the Node
 					community needs something on top of JS. However, we see several advantages to the Tame approach.  First off, it's 
-					simpler: just two new keywords (<span class="code_term">twait</span> and <span class="code_term">mkevent</span>), only
+					simpler: just two new keywords (<span class="code_term">await</span> and <span class="code_term">defer</span>), only
 					the former of which is a true language addition (the latter being syntactic sugar).  
 					Second, it's more powerful, allowing arbitrary parallelism, not just two-way parallelism
 					with <span class="code_term">waitfor..or</span>.  Finally, it's easier to integrate: traditional JS code can call tamed code, and vice-versa,
@@ -578,7 +578,7 @@ console.log (users);
 
 				<p class="answer">
 				        Sort of.  Code with <span class="code_term">try..catch</span> will compile in all cases, and run as expected when not
-					composed with <span class="code_term">twait</span> blocks.  But consider the following snippet of traditional JavaScript code:
+					composed with <span class="code_term">await</span> blocks.  But consider the following snippet of traditional JavaScript code:
 <pre class="prettyprint lang-js">
 try {
    setTimeout (function () { throw new Error ("XX"); }, 10);
@@ -590,7 +590,7 @@ try {
                                         the call stack.  Not surprisingly, this tamed version exhibits the same behavior:
 <pre class="prettyprint lang-js">
 try {
-   twait setTimeout (mkevent (), 10);
+   await setTimeout (defer (), 10);
    throw new Error ("XX");
 } catch (e) {
    console.log ("Caught: " + e);
